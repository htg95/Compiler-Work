
INSTALLING PLUTO

PREREQUISITES

A Linux distribution. Pluto has been tested on x86 and x86-64 machines 
running Fedora, Ubuntu, and RedHat Enterprise Server.  Solaris should also 
be fine if you have GNU utilities. In order to use the development version 
from Pluto's git repository, automatic build system tools including 
autoconf, automake, and libtool are needed. GMP (GNU multi precision 
arithmetic library) is needed by ISL (one of the included libraries). If 
it's not already on your system, it can be installed easily with, for 
eg., eg., 'sudo yum -y install gmp gmp-devel' on a Fedora. It is also 
recommended astyle and indent be installed if a user wishes to browse 
through generated code.

Pluto includes all polyhedral libraries that it depends on.


BUILDING PLUTO

Stable release

$ tar zxvf pluto-0.11.4.tar.gz
$ cd pluto-0.11.4/
$ ./configure
$ make
$ make test

configure can be provided --with-isl-prefix=<isl install location> to 
build with another isl, otherwise the bundled isl is used.

Development version from Git

$ git clone git://repo.or.cz/pluto.git
$ cd pluto/
$ git submodule init 
$ git submodule update
$ ./autogen.sh
$ ./configure [--enable-debug] [--with-isl-prefix=<isl install location>]
$ make
$ make test

* --with-isl-prefix=<location> to compile and link with an already installed 
isl. By default, the version of isl bundled with Pluto will be used.

'polycc' is the wrapper script around src/pluto (core transformer) and all 
other components. 'polycc' runs all of these in sequence on an input C 
program (with the section to  parallelize/optimize marked) and is what a 
user should use on input. Output generated is OpenMP parallel C code that 
can be readily compiled and run on shared-memory parallel machines like 
general-purpose multicores. libpluto.{so,a} is also built and can be found 
in src/.libs/. 'make install' will install it.


TRYING A NEW CODE

- Use '#pragma scop' and '#pragma endscop' around the section of code 
  you want to parallelize/optimize.

- Then, just run 
    
    ./polycc <C source file> --parallel --tile

  The transformation is also printed out, and test.par.c will have the 
  parallelized code. If you want to see intermediate files, like the 
  .cloog file generated (.opt.cloog, .tiled.cloog, or .par.cloog 
  depending on command-line options provided), use --debug on command 
  line.

- Tile sizes can be specified in a file 'tile.sizes', otherwise default 
  sizes will be set. See doc/DOC.txt on how to specify the sizes.

To run a good number of experiments on a code, it is best to use the setup 
created for example codes in the examples/ directory.  If you do not have 
ICC (Intel C compiler), uncomment line 7 and comment line 
8 of examples/common.mk to use GCC.

- Just copy one of the sample directories in examples/, edit Makefile (SRC = 
  )

- do a make (this will build all executables; 'orig' is the original code 
  compiled with the native compiler, 'tiled' is the tiled code, 'par' is the 
  OpenMP parallelized+locality optimized code, 'lbpar' with diamond tiling 
  when possible. One could do 'make <target>' where target can be orig, 
  orig_par, opt, tiled, par, lbpar, etc. (see examples/common.mk for full 
  list)

- 'make test' to test for correctness, 'make perf', 'make lbperf' to compare 
performance


COMMAND-LINE OPTIONS

Run

./polycc -h 

or see documentation (doc/DOC.txt) for details



To run the original unparallelized code:

$ ./orig

To run the locality optimized version generated by Pluto:

$ ./tiled

- 'make clean' in the particular example's directory removes all executables 
    as well as generated codes







